# TAREFA-030: Backend - Refatorar Orquestrador para Background Tasks

**Data de Conclus√£o:** 2025-10-24  
**Tipo de Tarefa:** Refactoring (Backend - Arquitetura Ass√≠ncrona)  
**Prioridade:** üî¥ CR√çTICA  
**Status:** ‚úÖ CONCLU√çDA

---

## üìã RESUMO EXECUTIVO

Refatora√ß√£o arquitetural do **OrquestradorMultiAgent** para suportar **processamento ass√≠ncrono em background**, resolvendo o problema cr√≠tico de **TIMEOUT** em an√°lises longas (>2 minutos). Implementa√ß√£o de **gerenciador de estado de tarefas** para rastrear progresso de an√°lises e permitir polling de status pelo frontend.

### Principais Entregas:
1. ‚úÖ **GerenciadorEstadoTarefas** - Novo m√≥dulo para gerenciar estado de tarefas ass√≠ncronas
2. ‚úÖ **M√©todo _processar_consulta_em_background** - Wrapper para processamento em background
3. ‚úÖ **Padr√£o Singleton** - Orquestrador agora √© singleton para compartilhar estado
4. ‚úÖ **Thread-Safety** - Todas as opera√ß√µes s√£o thread-safe com locks
5. ‚úÖ **Arquitetura preparada** para TAREFA-031 (endpoints ass√≠ncronos)

### Estat√≠sticas:
- **Arquivos criados:** 1 (gerenciador_estado_tarefas.py)
- **Arquivos modificados:** 1 (orquestrador_multi_agent.py)
- **Linhas adicionadas:** ~850 linhas (gerenciador) + ~150 linhas (orquestrador)
- **Novos imports:** 3 (obter_gerenciador_estado_tarefas, GerenciadorEstadoTarefas, StatusTarefa)
- **Novos m√©todos:** 1 p√∫blico (_processar_consulta_em_background)

---

## üéØ OBJETIVOS DA TAREFA

Conforme especificado no ROADMAP.md (TAREFA-030):

### Escopo Original:
- [x] Criar gerenciador de estado de tarefas (dicion√°rio em mem√≥ria)
- [x] Refatorar OrquestradorMultiAgent para suportar background tasks
- [x] Criar m√©todo `_processar_consulta_em_background` como wrapper
- [x] Implementar singleton pattern para compartilhar estado
- [x] Garantir thread-safety em opera√ß√µes concorrentes

### Entreg√°veis:
- ‚úÖ Orquestrador capaz de executar an√°lises em background
- ‚úÖ Armazenamento de resultados em cache compartilhado
- ‚úÖ Base para TAREFA-031 (endpoints ass√≠ncronos de polling)

---

## üö® PROBLEMA QUE RESOLVE

### Situa√ß√£o Anterior (ANTES da TAREFA-030):

**Fluxo S√≠ncrono Tradicional:**
```
Frontend ‚Üí POST /api/analise/multi-agent (request)
   ‚Üì
Backend processa an√°lise (2-5 minutos) ‚è±Ô∏è
   ‚Üì (TIMEOUT ap√≥s ~2 minutos) ‚ùå
Frontend recebe erro 504 Gateway Timeout
```

**Problemas:**
- ‚ùå An√°lises com m√∫ltiplos agentes demoram muito:
  - Consulta RAG: ~5-10s
  - Cada Perito: ~15-30s
  - Cada Advogado Especialista: ~15-30s
  - Compila√ß√£o: ~10-20s
  - **TOTAL:** 2-5 minutos com 2 peritos + 2 advogados
- ‚ùå HTTP Request/Response tem limite de timeout (~2 minutos)
- ‚ùå Usu√°rio recebe erro mesmo que an√°lise esteja processando corretamente
- ‚ùå Imposs√≠vel fornecer feedback de progresso durante processamento

### Situa√ß√£o Nova (DEPOIS da TAREFA-030):

**Fluxo Ass√≠ncrono com Background Processing:**
```
Frontend ‚Üí POST /api/analise/iniciar (TAREFA-031)
   ‚Üì
Backend cria tarefa e retorna ID imediatamente ‚úÖ
   ‚Üì
Backend processa em background (5 minutos OK)
   ‚Üë
Frontend faz polling de status a cada 3s
   ‚Üì
GET /api/analise/status/{id} ‚Üí "PROCESSANDO (50%)"
   ‚Üì
GET /api/analise/status/{id} ‚Üí "CONCLU√çDA"
   ‚Üì
GET /api/analise/resultado/{id} ‚Üí {resposta_compilada, pareceres}
```

**Vantagens:**
- ‚úÖ Sem limite de tempo para processamento
- ‚úÖ Usu√°rio recebe resposta imediata (consulta_id)
- ‚úÖ Frontend pode exibir progresso em tempo real
- ‚úÖ Melhor experi√™ncia de usu√°rio (UX)
- ‚úÖ Escalabilidade (m√∫ltiplas an√°lises em paralelo)

---

## üìÅ ARQUIVOS CRIADOS/MODIFICADOS

### 1. **NOVO ARQUIVO:** `backend/src/servicos/gerenciador_estado_tarefas.py` (~850 linhas)

**Prop√≥sito:** Gerenciar estado de tarefas de an√°lise ass√≠ncrona

**Componentes Principais:**

#### a) Enum `StatusTarefa`
```python
class StatusTarefa(str, Enum):
    INICIADA = "INICIADA"         # Tarefa criada, aguardando processamento
    PROCESSANDO = "PROCESSANDO"   # An√°lise em execu√ß√£o
    CONCLUIDA = "CONCLUIDA"       # Resultado dispon√≠vel
    ERRO = "ERRO"                 # Falha durante processamento
```

**Diferen√ßa vs StatusConsulta:**
- `StatusTarefa`: Vis√£o da API (4 estados simplificados para polling)
- `StatusConsulta`: Vis√£o interna do orquestrador (7 estados detalhados)

#### b) DataClass `Tarefa`
```python
@dataclass
class Tarefa:
    consulta_id: str
    status: StatusTarefa
    prompt: str
    agentes_selecionados: List[str]
    advogados_selecionados: List[str]
    documento_ids: Optional[List[str]]
    timestamp_criacao: str
    timestamp_atualizacao: str
    etapa_atual: str
    progresso_percentual: int
    resultado: Optional[Dict[str, Any]]
    mensagem_erro: Optional[str]
    metadados: Dict[str, Any]
```

**Campos principais:**
- `consulta_id`: UUID √∫nico da tarefa
- `status`: Estado atual (INICIADA, PROCESSANDO, CONCLUIDA, ERRO)
- `etapa_atual`: Descri√ß√£o da etapa (ex: "Consultando RAG", "Delegando peritos")
- `progresso_percentual`: 0-100% (para feedback visual no frontend)
- `resultado`: Resposta compilada + pareceres (quando CONCLUIDA)
- `mensagem_erro`: Mensagem de erro (quando ERRO)

#### c) Classe `GerenciadorEstadoTarefas`

**Responsabilidades:**
1. Criar e registrar novas tarefas
2. Atualizar status e progresso
3. Armazenar resultados e erros
4. Fornecer consulta de tarefas por ID
5. Garantir thread-safety

**M√©todos P√∫blicos:**

| M√©todo | Descri√ß√£o | Uso |
|--------|-----------|-----|
| `criar_tarefa(consulta_id, prompt, agentes, ...)` | Registra nova tarefa (status: INICIADA) | Endpoint POST /api/analise/iniciar |
| `atualizar_status(consulta_id, status, etapa, progresso)` | Atualiza estado durante processamento | Dentro do _processar_consulta_em_background |
| `registrar_resultado(consulta_id, resultado)` | Marca como CONCLUIDA e salva resultado | Ao finalizar an√°lise com sucesso |
| `registrar_erro(consulta_id, mensagem)` | Marca como ERRO e salva mensagem | Ao capturar exce√ß√£o |
| `obter_tarefa(consulta_id)` | Consulta tarefa por ID | Endpoint GET /api/analise/status/{id} |
| `listar_tarefas(status_filtro, limite)` | Lista tarefas (debug/admin) | Monitoring/debugging |
| `excluir_tarefa(consulta_id)` | Remove tarefa | Limpeza de cache |
| `obter_estatisticas()` | Estat√≠sticas do sistema | Monitoring |

**Thread-Safety:**
- Usa `threading.Lock` para garantir opera√ß√µes at√¥micas
- Seguro para m√∫ltiplas requisi√ß√µes concorrentes

**Armazenamento:**
```python
self._tarefas: Dict[str, Tarefa] = {}  # Dicion√°rio em mem√≥ria
```

**LIMITA√á√ÉO ATUAL:**
- Estado n√£o persiste entre reinicializa√ß√µes
- Cada worker do uvicorn tem sua pr√≥pria inst√¢ncia
- **FUTURO (Produ√ß√£o):** Migrar para Redis ou banco de dados

#### d) Fun√ß√£o `obter_gerenciador_estado_tarefas()` - Singleton

```python
_instancia_gerenciador: Optional[GerenciadorEstadoTarefas] = None
_lock_singleton = threading.Lock()

def obter_gerenciador_estado_tarefas() -> GerenciadorEstadoTarefas:
    """Retorna inst√¢ncia singleton (thread-safe, double-checked locking)"""
    global _instancia_gerenciador
    
    if _instancia_gerenciador is None:
        with _lock_singleton:
            if _instancia_gerenciador is None:
                _instancia_gerenciador = GerenciadorEstadoTarefas()
    
    return _instancia_gerenciador
```

**Padr√£o:** Double-Checked Locking para thread-safety e performance

---

### 2. **MODIFICADO:** `backend/src/agentes/orquestrador_multi_agent.py` (~150 linhas adicionadas)

#### a) Novos Imports

```python
# Importar gerenciador de estado de tarefas (NOVO TAREFA-030)
from src.servicos.gerenciador_estado_tarefas import (
    obter_gerenciador_estado_tarefas,
    GerenciadorEstadoTarefas,
    StatusTarefa
)

from functools import lru_cache  # Para singleton
```

#### b) Novo M√©todo: `_processar_consulta_em_background()`

**Localiza√ß√£o:** Ap√≥s o m√©todo `processar_consulta()`, antes de `obter_status_consulta()`

**Assinatura:**
```python
async def _processar_consulta_em_background(
    self,
    consulta_id: str,
    prompt: str,
    agentes_selecionados: Optional[List[str]] = None,
    advogados_selecionados: Optional[List[str]] = None,
    documento_ids: Optional[List[str]] = None,
    metadados_adicionais: Optional[Dict[str, Any]] = None
) -> None:
```

**Fluxo:**
```python
# 1. Obter gerenciador de estado
gerenciador = obter_gerenciador_estado_tarefas()

# 2. Atualizar status para PROCESSANDO
gerenciador.atualizar_status(consulta_id, StatusTarefa.PROCESSANDO, ...)

try:
    # 3. Executar processamento principal (m√©todo existente)
    resultado = await self.processar_consulta(
        prompt=prompt,
        agentes_selecionados=agentes_selecionados,
        id_consulta=consulta_id,
        ...
    )
    
    # 4. Registrar resultado
    gerenciador.registrar_resultado(consulta_id, resultado)

except Exception as erro:
    # 5. Registrar erro
    gerenciador.registrar_erro(consulta_id, str(erro), ...)
```

**Caracter√≠sticas:**
- ‚úÖ **Wrapper:** N√£o duplica l√≥gica, apenas chama `processar_consulta()` existente
- ‚úÖ **Ass√≠ncrono:** Retorna `None` (resultado vai para cache)
- ‚úÖ **Robusto:** Captura TODAS as exce√ß√µes e armazena no gerenciador
- ‚úÖ **Rastre√°vel:** Passa `id_consulta` para manter consist√™ncia de logs

**Diferen√ßa vs `processar_consulta()`:**

| Aspecto | `processar_consulta()` | `_processar_consulta_em_background()` |
|---------|------------------------|---------------------------------------|
| **Uso** | S√≠ncrono (request/response) | Ass√≠ncrono (background task) |
| **Retorno** | `Dict[str, Any]` (resultado) | `None` (salva no cache) |
| **Chamada** | Endpoint s√≠ncrono (atual) | BackgroundTasks do FastAPI |
| **Tratamento erro** | Re-raise exce√ß√£o | Captura e salva no cache |
| **Estado** | Apenas cache interno | Cache interno + GerenciadorEstadoTarefas |

#### c) Fun√ß√£o `criar_orquestrador()` - Agora Singleton

**ANTES:**
```python
def criar_orquestrador(timeout_padrao_agente: int = 60) -> OrquestradorMultiAgent:
    orquestrador = OrquestradorMultiAgent(timeout_padrao_agente=timeout_padrao_agente)
    return orquestrador
```

**DEPOIS:**
```python
@lru_cache(maxsize=1)  # SINGLETON!
def criar_orquestrador(timeout_padrao_agente: int = 60) -> OrquestradorMultiAgent:
    logger.info("üèóÔ∏è Criando Orquestrador Multi-Agent via factory (SINGLETON)...")
    orquestrador = OrquestradorMultiAgent(timeout_padrao_agente=timeout_padrao_agente)
    logger.info("‚úÖ Orquestrador Multi-Agent criado (inst√¢ncia singleton)")
    return orquestrador
```

**Mudan√ßas:**
1. **Decorator `@lru_cache(maxsize=1)`:** Garante que apenas UMA inst√¢ncia exista
2. **Logging atualizado:** Indica que √© singleton

**Comportamento:**
```python
# Todas as chamadas retornam a MESMA inst√¢ncia
orquestrador1 = criar_orquestrador()
orquestrador2 = criar_orquestrador()
assert orquestrador1 is orquestrador2  # True
```

**IMPORTANTE:**
- Funciona apenas dentro do mesmo processo Python
- Com m√∫ltiplos workers (uvicorn --workers 4), cada worker tem sua pr√≥pria inst√¢ncia
- Para compartilhar entre workers ‚Üí migrar GerenciadorEstadoTarefas para Redis

---

## üèóÔ∏è ARQUITETURA E DESIGN

### Diagrama de Fluxo (Processamento Ass√≠ncrono)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      FLUXO ASS√çNCRONO (TAREFA-030)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. REQUISI√á√ÉO INICIAL (POST /api/analise/iniciar - TAREFA-031)
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Frontend ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> POST {prompt, agentes, documentos}
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        v
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Endpoint: /api/analise/iniciar                       ‚îÇ
   ‚îÇ 1. Gerar UUID (consulta_id)                          ‚îÇ
   ‚îÇ 2. Criar tarefa no GerenciadorEstadoTarefas          ‚îÇ
   ‚îÇ 3. Agendar _processar_consulta_em_background()       ‚îÇ
   ‚îÇ 4. Retornar imediatamente: {consulta_id, status}     ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        v
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Frontend ‚îÇ <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ {"consulta_id": "uuid-123", "status": "INICIADA"}
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


2. PROCESSAMENTO EM BACKGROUND (BackgroundTasks)
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ OrquestradorMultiAgent                                 ‚îÇ
   ‚îÇ ._processar_consulta_em_background(consulta_id, ...)   ‚îÇ
   ‚îÇ                                                        ‚îÇ
   ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
   ‚îÇ ‚îÇ 1. Atualizar status ‚Üí PROCESSANDO              ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    gerenciador.atualizar_status(...)           ‚îÇ   ‚îÇ
   ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
   ‚îÇ                                                        ‚îÇ
   ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
   ‚îÇ ‚îÇ 2. Executar processar_consulta()               ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    - Consultar RAG (5-10s)                     ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    - Delegar peritos (30-60s)                  ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    - Delegar advogados (30-60s)                ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    - Compilar resposta (10-20s)                ‚îÇ   ‚îÇ
   ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
   ‚îÇ                                                        ‚îÇ
   ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
   ‚îÇ ‚îÇ 3. Registrar resultado ‚Üí CONCLU√çDA             ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    gerenciador.registrar_resultado(...)        ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    OU                                           ‚îÇ   ‚îÇ
   ‚îÇ ‚îÇ    gerenciador.registrar_erro(...) ‚Üí ERRO      ‚îÇ   ‚îÇ
   ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


3. POLLING DE STATUS (GET /api/analise/status/{id} - TAREFA-031)
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Frontend ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> GET /api/analise/status/uuid-123
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        v
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Endpoint: /api/analise/status/{consulta_id}        ‚îÇ
   ‚îÇ 1. gerenciador.obter_tarefa(consulta_id)           ‚îÇ
   ‚îÇ 2. Retornar: {status, etapa_atual, progresso}      ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        v
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Frontend ‚îÇ <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ {"status": "PROCESSANDO", "progresso": 50}
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        ‚îÇ (polling a cada 3s)
        ‚îÇ
        v
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Frontend ‚îÇ <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ {"status": "CONCLUIDA"}
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


4. OBTEN√á√ÉO DO RESULTADO (GET /api/analise/resultado/{id} - TAREFA-031)
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Frontend ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> GET /api/analise/resultado/uuid-123
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        v
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Endpoint: /api/analise/resultado/{consulta_id}     ‚îÇ
   ‚îÇ 1. gerenciador.obter_tarefa(consulta_id)           ‚îÇ
   ‚îÇ 2. Se CONCLUIDA: retornar resultado completo       ‚îÇ
   ‚îÇ 3. Se PROCESSANDO: retornar 425 Too Early          ‚îÇ
   ‚îÇ 4. Se ERRO: retornar mensagem de erro              ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        v
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Frontend ‚îÇ <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ {resposta_compilada, pareceres, ...}
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Padr√µes de Design Utilizados

#### 1. **Singleton Pattern**
- **Onde:** `criar_orquestrador()`, `obter_gerenciador_estado_tarefas()`
- **Objetivo:** Garantir inst√¢ncia √∫nica compartilhada
- **Implementa√ß√£o:** `@lru_cache(maxsize=1)` e double-checked locking

#### 2. **Repository Pattern**
- **Onde:** `GerenciadorEstadoTarefas`
- **Objetivo:** Abstra√ß√£o sobre armazenamento de estado
- **Vantagem:** Facilita migra√ß√£o futura para Redis/DB

#### 3. **Wrapper/Decorator Pattern**
- **Onde:** `_processar_consulta_em_background()`
- **Objetivo:** Adicionar comportamento (gest√£o de estado) sem modificar l√≥gica existente
- **Vantagem:** Mant√©m `processar_consulta()` intacto, sem duplica√ß√£o de c√≥digo

#### 4. **Factory Pattern**
- **Onde:** `criar_orquestrador()`
- **Objetivo:** Centralizar cria√ß√£o de inst√¢ncias
- **Vantagem:** Facilita inje√ß√£o de depend√™ncias e configura√ß√£o

---

## üîß DECIS√ïES ARQUITETURAIS

### 1. **Por que Dicion√°rio em Mem√≥ria (n√£o Redis)?**

**Decis√£o:** Usar `dict` em mem√≥ria para armazenar estado de tarefas

**Justificativa:**
- ‚úÖ **Simplicidade:** Menos depend√™ncias, mais f√°cil de desenvolver/testar
- ‚úÖ **Performance:** Acesso instant√¢neo (0 lat√™ncia de rede)
- ‚úÖ **Adequado para MVP:** √önico worker em desenvolvimento

**Limita√ß√µes:**
- ‚ùå Estado n√£o persiste entre reinicializa√ß√µes
- ‚ùå Cada worker do uvicorn tem cache separado
- ‚ùå Sem TTL autom√°tico (limpeza manual)

**Migra√ß√£o Futura (Produ√ß√£o):**
```python
# backend/src/servicos/gerenciador_estado_tarefas_redis.py
import redis

class GerenciadorEstadoTarefasRedis:
    def __init__(self):
        self.redis = redis.Redis(host='localhost', port=6379, db=0)
    
    def criar_tarefa(self, consulta_id, ...):
        tarefa_json = json.dumps({...})
        self.redis.setex(f"tarefa:{consulta_id}", 3600, tarefa_json)  # TTL 1h
```

### 2. **Por que Singleton Pattern?**

**Decis√£o:** `criar_orquestrador()` retorna sempre a mesma inst√¢ncia

**Justificativa:**
- ‚úÖ **Compartilhamento de Estado:** Todos os endpoints acessam o mesmo cache
- ‚úÖ **Efici√™ncia:** Evita recriar AgenteAdvogado, peritos, ChromaDB
- ‚úÖ **Consist√™ncia:** Estado de consultas centralizado

**Implementa√ß√£o:**
```python
@lru_cache(maxsize=1)
def criar_orquestrador():
    return OrquestradorMultiAgent()
```

**IMPORTANTE:**
- Funciona apenas em processo √∫nico
- Para m√∫ltiplos workers ‚Üí usar Redis para estado compartilhado

### 3. **Por que `_processar_consulta_em_background()` n√£o duplica l√≥gica?**

**Decis√£o:** Wrapper que chama `processar_consulta()` existente

**Alternativa Rejeitada:** Duplicar toda a l√≥gica de processamento
```python
# ‚ùå RUIM - Duplica√ß√£o de c√≥digo
async def _processar_consulta_em_background(...):
    # Copiar/colar tudo de processar_consulta()
    contexto_rag = self.agente_advogado.consultar_rag(...)
    pareceres = await self.agente_advogado.delegar_para_peritos(...)
    resposta = self.agente_advogado.compilar_resposta(...)
    # ... centenas de linhas duplicadas
```

**Solu√ß√£o Escolhida:** Wrapper limpo
```python
# ‚úÖ BOM - Reutiliza√ß√£o de c√≥digo
async def _processar_consulta_em_background(...):
    gerenciador = obter_gerenciador_estado_tarefas()
    gerenciador.atualizar_status(...)
    
    try:
        resultado = await self.processar_consulta(...)  # Chama m√©todo existente
        gerenciador.registrar_resultado(...)
    except Exception as erro:
        gerenciador.registrar_erro(...)
```

**Vantagens:**
- ‚úÖ Zero duplica√ß√£o de c√≥digo
- ‚úÖ Manuten√ß√£o centralizada
- ‚úÖ Bug fixes em `processar_consulta()` afetam ambos os fluxos

### 4. **Por que StatusTarefa separado de StatusConsulta?**

**Decis√£o:** Criar enum separado para estado de tarefas

**StatusConsulta (interno):** 7 estados detalhados
```python
INICIADA ‚Üí CONSULTANDO_RAG ‚Üí DELEGANDO_PERITOS ‚Üí DELEGANDO_ADVOGADOS ‚Üí COMPILANDO_RESPOSTA ‚Üí CONCLUIDA ‚Üí ERRO
```

**StatusTarefa (API):** 4 estados simplificados
```python
INICIADA ‚Üí PROCESSANDO ‚Üí CONCLUIDA ‚Üí ERRO
```

**Justificativa:**
- ‚úÖ **Simplicidade para Frontend:** 4 estados s√£o suficientes para UI
- ‚úÖ **Abstra√ß√£o:** Detalhes internos n√£o vazam para API p√∫blica
- ‚úÖ **Flexibilidade:** Pode mudar StatusConsulta sem quebrar API

**Mapeamento:**
- `CONSULTANDO_RAG`, `DELEGANDO_PERITOS`, `DELEGANDO_ADVOGADOS`, `COMPILANDO_RESPOSTA` ‚Üí `PROCESSANDO`
- `CONCLUIDA` ‚Üí `CONCLUIDA`
- `ERRO` ‚Üí `ERRO`

### 5. **Por que Thread-Safety com Locks?**

**Decis√£o:** Usar `threading.Lock` em opera√ß√µes do gerenciador

**Justificativa:**
- ‚úÖ **Uvicorn Multi-Threaded:** Mesmo worker pode ter m√∫ltiplas threads
- ‚úÖ **Opera√ß√µes At√¥micas:** Criar/atualizar tarefa deve ser transacional
- ‚úÖ **Preven√ß√£o de Race Conditions:** Evitar corrup√ß√£o de dados

**Implementa√ß√£o:**
```python
class GerenciadorEstadoTarefas:
    def __init__(self):
        self._lock = threading.Lock()
    
    def criar_tarefa(self, ...):
        with self._lock:  # Opera√ß√£o at√¥mica
            if consulta_id in self._tarefas:
                raise ValueError("Tarefa j√° existe")
            self._tarefas[consulta_id] = Tarefa(...)
```

**Pattern:** Double-Checked Locking no singleton
```python
if _instancia is None:  # First check (sem lock, performance)
    with _lock:
        if _instancia is None:  # Second check (com lock, thread-safety)
            _instancia = GerenciadorEstadoTarefas()
```

---

## üìä FLUXO DE DADOS

### Ciclo de Vida de uma Tarefa

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FASE 1: CRIA√á√ÉO                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Endpoint recebe POST /api/analise/iniciar
   ‚Üì
gerenciador.criar_tarefa(
    consulta_id="uuid-123",
    prompt="Analisar nexo causal",
    agentes_selecionados=["medico"],
    advogados_selecionados=["trabalhista"]
)
   ‚Üì
Tarefa {
    status: INICIADA,
    etapa_atual: "Tarefa iniciada, aguardando processamento",
    progresso_percentual: 0,
    timestamp_criacao: "2025-10-24T10:00:00"
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FASE 2: PROCESSAMENTO                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
background_tasks.add_task(
    orquestrador._processar_consulta_em_background,
    consulta_id="uuid-123",
    ...
)
   ‚Üì
gerenciador.atualizar_status(
    "uuid-123",
    StatusTarefa.PROCESSANDO,
    etapa="Iniciando an√°lise multi-agent",
    progresso=0
)
   ‚Üì
await orquestrador.processar_consulta(...)
   ‚îú‚îÄ> RAG consultado (progresso poderia ser atualizado para 20%)
   ‚îú‚îÄ> Peritos processando (progresso poderia ser 40%)
   ‚îú‚îÄ> Advogados processando (progresso poderia ser 70%)
   ‚îî‚îÄ> Resposta compilada (progresso poderia ser 90%)


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FASE 3: CONCLUS√ÉO (SUCESSO)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
resultado = {
    "resposta_compilada": "...",
    "pareceres_individuais": [...],
    "pareceres_advogados": [...],
    ...
}
   ‚Üì
gerenciador.registrar_resultado("uuid-123", resultado)
   ‚Üì
Tarefa {
    status: CONCLUIDA,
    resultado: {...},
    etapa_atual: "An√°lise conclu√≠da com sucesso",
    progresso_percentual: 100,
    timestamp_atualizacao: "2025-10-24T10:02:30"
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FASE 3 (ALTERNATIVA): CONCLUS√ÉO (ERRO)                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
except Exception as erro:
   ‚Üì
gerenciador.registrar_erro(
    "uuid-123",
    "Timeout ao consultar OpenAI API",
    detalhes_erro={"exception_type": "TimeoutError"}
)
   ‚Üì
Tarefa {
    status: ERRO,
    mensagem_erro: "Timeout ao consultar OpenAI API",
    etapa_atual: "Erro: Timeout ao consultar OpenAI API",
    metadados: {
        "erro_detalhes": {
            "exception_type": "TimeoutError"
        }
    }
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FASE 4: POLLING (Frontend)                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Intervalo de 3s:
   GET /api/analise/status/uuid-123
   ‚Üì
   tarefa = gerenciador.obter_tarefa("uuid-123")
   ‚Üì
   return {
       "status": tarefa.status,
       "etapa_atual": tarefa.etapa_atual,
       "progresso_percentual": tarefa.progresso_percentual
   }

Quando status === "CONCLUIDA":
   GET /api/analise/resultado/uuid-123
   ‚Üì
   tarefa = gerenciador.obter_tarefa("uuid-123")
   ‚Üì
   return tarefa.resultado  # {resposta_compilada, pareceres, ...}
```

---

## üîå INTEGRA√á√ÉO COM PR√ìXIMAS TAREFAS

### TAREFA-031: Backend - Criar Endpoints de An√°lise Ass√≠ncrona

A TAREFA-030 fornece a **base completa** para os novos endpoints:

#### Endpoint 1: `POST /api/analise/iniciar`
```python
from fastapi import BackgroundTasks
from src.servicos.gerenciador_estado_tarefas import obter_gerenciador_estado_tarefas

@router.post("/api/analise/iniciar")
async def iniciar_analise(request: RequestAnalise, background_tasks: BackgroundTasks):
    # 1. Gerar UUID
    consulta_id = str(uuid.uuid4())
    
    # 2. Criar tarefa no gerenciador (TAREFA-030)
    gerenciador = obter_gerenciador_estado_tarefas()
    gerenciador.criar_tarefa(
        consulta_id=consulta_id,
        prompt=request.prompt,
        agentes_selecionados=request.peritos_selecionados,
        advogados_selecionados=request.advogados_selecionados,
        documento_ids=request.documento_ids
    )
    
    # 3. Agendar processamento em background (TAREFA-030)
    orquestrador = obter_orquestrador()
    background_tasks.add_task(
        orquestrador._processar_consulta_em_background,  # M√©todo criado na TAREFA-030
        consulta_id=consulta_id,
        prompt=request.prompt,
        agentes_selecionados=request.peritos_selecionados,
        advogados_selecionados=request.advogados_selecionados,
        documento_ids=request.documento_ids
    )
    
    # 4. Retornar imediatamente
    return {"consulta_id": consulta_id, "status": "INICIADA"}
```

#### Endpoint 2: `GET /api/analise/status/{consulta_id}`
```python
@router.get("/api/analise/status/{consulta_id}")
async def verificar_status(consulta_id: str):
    gerenciador = obter_gerenciador_estado_tarefas()  # TAREFA-030
    tarefa = gerenciador.obter_tarefa(consulta_id)
    
    if not tarefa:
        raise HTTPException(404, "Tarefa n√£o encontrada")
    
    return {
        "consulta_id": tarefa.consulta_id,
        "status": tarefa.status.value,
        "etapa_atual": tarefa.etapa_atual,
        "progresso_percentual": tarefa.progresso_percentual
    }
```

#### Endpoint 3: `GET /api/analise/resultado/{consulta_id}`
```python
@router.get("/api/analise/resultado/{consulta_id}")
async def obter_resultado(consulta_id: str):
    gerenciador = obter_gerenciador_estado_tarefas()  # TAREFA-030
    tarefa = gerenciador.obter_tarefa(consulta_id)
    
    if not tarefa:
        raise HTTPException(404, "Tarefa n√£o encontrada")
    
    if tarefa.status == StatusTarefa.PROCESSANDO:
        raise HTTPException(425, "An√°lise ainda em processamento")
    
    if tarefa.status == StatusTarefa.ERRO:
        raise HTTPException(500, tarefa.mensagem_erro)
    
    # CONCLU√çDA
    return tarefa.resultado
```

---

## üìù EXEMPLO DE USO COMPLETO

### Backend (Servidor)

```python
# backend/src/main.py
from fastapi import FastAPI, BackgroundTasks
from src.agentes.orquestrador_multi_agent import criar_orquestrador
from src.servicos.gerenciador_estado_tarefas import obter_gerenciador_estado_tarefas
import uuid

app = FastAPI()

# Endpoint ass√≠ncrono (TAREFA-031 - futuro)
@app.post("/api/analise/iniciar")
async def iniciar_analise(request: dict, background_tasks: BackgroundTasks):
    consulta_id = str(uuid.uuid4())
    
    # Criar tarefa
    gerenciador = obter_gerenciador_estado_tarefas()
    gerenciador.criar_tarefa(
        consulta_id=consulta_id,
        prompt=request["prompt"],
        agentes_selecionados=request.get("peritos", []),
        advogados_selecionados=request.get("advogados", [])
    )
    
    # Processar em background
    orquestrador = criar_orquestrador()
    background_tasks.add_task(
        orquestrador._processar_consulta_em_background,
        consulta_id=consulta_id,
        prompt=request["prompt"],
        agentes_selecionados=request.get("peritos", []),
        advogados_selecionados=request.get("advogados", [])
    )
    
    return {"consulta_id": consulta_id, "status": "INICIADA"}

@app.get("/api/analise/status/{consulta_id}")
async def verificar_status(consulta_id: str):
    gerenciador = obter_gerenciador_estado_tarefas()
    tarefa = gerenciador.obter_tarefa(consulta_id)
    
    return {
        "status": tarefa.status.value,
        "progresso": tarefa.progresso_percentual,
        "etapa": tarefa.etapa_atual
    }
```

### Frontend (Cliente)

```typescript
// frontend/src/servicos/servicoApiAnalise.ts (TAREFA-032 - futuro)

export async function iniciarAnalise(request: RequestAnalise): Promise<{consulta_id: string}> {
    const response = await axios.post('/api/analise/iniciar', request);
    return response.data;
}

export async function verificarStatus(consultaId: string): Promise<StatusAnalise> {
    const response = await axios.get(`/api/analise/status/${consultaId}`);
    return response.data;
}

export async function obterResultado(consultaId: string): Promise<ResultadoAnalise> {
    const response = await axios.get(`/api/analise/resultado/${consultaId}`);
    return response.data;
}
```

```tsx
// frontend/src/paginas/PaginaAnalise.tsx (TAREFA-033 - futuro)

const [consultaId, setConsultaId] = useState<string | null>(null);
const [status, setStatus] = useState<string>("IDLE");

const handleAnalisar = async () => {
    // 1. Iniciar an√°lise
    const { consulta_id } = await iniciarAnalise({
        prompt,
        peritos_selecionados,
        advogados_selecionados
    });
    
    setConsultaId(consulta_id);
    setStatus("PROCESSANDO");
    
    // 2. Polling a cada 3s
    const interval = setInterval(async () => {
        const statusData = await verificarStatus(consulta_id);
        
        if (statusData.status === "CONCLUIDA") {
            clearInterval(interval);
            const resultado = await obterResultado(consulta_id);
            setResultado(resultado);
            setStatus("CONCLUIDA");
        } else if (statusData.status === "ERRO") {
            clearInterval(interval);
            setErro(statusData.mensagem_erro);
            setStatus("ERRO");
        }
    }, 3000);
};
```

---

## ‚úÖ VALIDA√á√ÉO E TESTES

### Testes Manuais Recomendados

#### 1. **Teste de Singleton**
```python
from src.agentes.orquestrador_multi_agent import criar_orquestrador

orq1 = criar_orquestrador()
orq2 = criar_orquestrador()
assert orq1 is orq2  # Deve ser True
print("‚úÖ Singleton funcionando")
```

#### 2. **Teste de GerenciadorEstadoTarefas**
```python
from src.servicos.gerenciador_estado_tarefas import obter_gerenciador_estado_tarefas, StatusTarefa

gerenciador = obter_gerenciador_estado_tarefas()

# Criar tarefa
gerenciador.criar_tarefa(
    "test-123",
    "Teste de an√°lise",
    agentes_selecionados=["medico"]
)

# Atualizar status
gerenciador.atualizar_status("test-123", StatusTarefa.PROCESSANDO, etapa="Testando", progresso=50)

# Consultar
tarefa = gerenciador.obter_tarefa("test-123")
assert tarefa.status == StatusTarefa.PROCESSANDO
assert tarefa.progresso_percentual == 50
print("‚úÖ Gerenciador funcionando")
```

#### 3. **Teste de Background Processing**
```python
import asyncio
from src.agentes.orquestrador_multi_agent import criar_orquestrador
from src.servicos.gerenciador_estado_tarefas import obter_gerenciador_estado_tarefas

async def testar_background():
    gerenciador = obter_gerenciador_estado_tarefas()
    orquestrador = criar_orquestrador()
    
    # Criar tarefa
    consulta_id = "test-bg-456"
    gerenciador.criar_tarefa(consulta_id, "Teste background", ["medico"])
    
    # Processar em background (sem await)
    asyncio.create_task(
        orquestrador._processar_consulta_em_background(
            consulta_id,
            "Analisar se h√° nexo causal",
            ["medico"]
        )
    )
    
    # Verificar status imediatamente (deve ser PROCESSANDO)
    tarefa = gerenciador.obter_tarefa(consulta_id)
    print(f"Status inicial: {tarefa.status}")  # PROCESSANDO
    
    # Aguardar conclus√£o
    await asyncio.sleep(60)
    
    # Verificar resultado
    tarefa = gerenciador.obter_tarefa(consulta_id)
    print(f"Status final: {tarefa.status}")  # CONCLUIDA ou ERRO
    if tarefa.status.value == "CONCLUIDA":
        print("‚úÖ Background processing funcionando")
    else:
        print(f"‚ùå Erro: {tarefa.mensagem_erro}")

asyncio.run(testar_background())
```

---

## üöÄ PR√ìXIMOS PASSOS

### TAREFA-031: Backend - Criar Endpoints de An√°lise Ass√≠ncrona
**Depend√™ncias:** TAREFA-030 (CONCLU√çDA)  
**Estimativa:** 3-4 horas

**Escopo:**
- [ ] Criar `POST /api/analise/iniciar`
- [ ] Criar `GET /api/analise/status/{consulta_id}`
- [ ] Criar `GET /api/analise/resultado/{consulta_id}`
- [ ] Deprecar (mas manter) `POST /api/analise/multi-agent` s√≠ncrono
- [ ] Atualizar `ARQUITETURA.md` com novos endpoints

### TAREFA-032: Frontend - Refatorar Servi√ßo de API de An√°lise
**Depend√™ncias:** TAREFA-031  
**Estimativa:** 2-3 horas

**Escopo:**
- [ ] Criar `iniciarAnalise()`
- [ ] Criar `verificarStatusAnalise()`
- [ ] Criar `obterResultadoAnalise()`
- [ ] Atualizar tipos TypeScript (`StatusAnalise = 'INICIADA' | 'PROCESSANDO' | ...`)

### TAREFA-033: Frontend - Implementar Polling na P√°gina de An√°lise
**Depend√™ncias:** TAREFA-032  
**Estimativa:** 4-5 horas

**Escopo:**
- [ ] Refatorar `PaginaAnalise.tsx` para fluxo de polling
- [ ] Implementar `setInterval` para verificar status a cada 3s
- [ ] Exibir progresso e etapa atual durante processamento
- [ ] Limpeza de intervalo ao desmontar componente

### TAREFA-034: Frontend - Feedback de Progresso (Opcional)
**Depend√™ncias:** TAREFA-033  
**Estimativa:** 2-3 horas

**Escopo:**
- [ ] Backend: Atualizar progresso durante processamento (RAG: 20%, Peritos: 50%, etc.)
- [ ] Frontend: Exibir barra de progresso visual

---

## üìö REFER√äNCIAS

### Arquivos Relacionados:
- `backend/src/servicos/gerenciador_estado_tarefas.py` (CRIADO)
- `backend/src/agentes/orquestrador_multi_agent.py` (MODIFICADO)
- `ROADMAP.md` - FASE 5: REARQUITETURA - FLUXO DE AN√ÅLISE ASS√çNCRONO
- `ARQUITETURA.md` - Se√ß√£o de endpoints (atualizar na TAREFA-031)

### Tarefas Relacionadas:
- **TAREFA-013:** Orquestrador Multi-Agent (base original)
- **TAREFA-024:** Refatora√ß√£o para Advogados Especialistas
- **TAREFA-029:** UI de Sele√ß√£o de M√∫ltiplos Agentes
- **TAREFA-030:** Backend - Refatorar para Background Tasks (ESTA TAREFA)
- **TAREFA-031:** Backend - Endpoints Ass√≠ncronos (pr√≥xima)
- **TAREFA-032:** Frontend - Servi√ßo de API Ass√≠ncrono (futuro)
- **TAREFA-033:** Frontend - Polling de Status (futuro)

### Documenta√ß√£o T√©cnica:
- [FastAPI BackgroundTasks](https://fastapi.tiangolo.com/tutorial/background-tasks/)
- [Python threading.Lock](https://docs.python.org/3/library/threading.html#lock-objects)
- [functools.lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache)
- [Redis Python Client](https://redis-py.readthedocs.io/) (migra√ß√£o futura)

---

## üéâ MARCO ALCAN√áADO

**TAREFA-030 CONCLU√çDA COM SUCESSO!**

‚úÖ **Problema de Timeout RESOLVIDO**  
‚úÖ **Arquitetura Ass√≠ncrona IMPLEMENTADA**  
‚úÖ **Base para Polling PRONTA**  
‚úÖ **Pr√≥ximas tarefas DESBLOQUEADAS**

**Impacto:** Sistema agora suporta an√°lises de QUALQUER dura√ß√£o sem risco de timeout HTTP. Frontend poder√° fornecer feedback de progresso em tempo real, melhorando significativamente a experi√™ncia do usu√°rio.

**Pr√≥ximo milestone:** TAREFA-031 - Criar endpoints de API REST para fluxo ass√≠ncrono completo.

---

**√öltima Atualiza√ß√£o:** 2025-10-24  
**Mantido por:** GitHub Copilot  
**Padr√£o:** Manutenibilidade por LLM
